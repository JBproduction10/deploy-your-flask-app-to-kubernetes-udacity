1. Prerequisite
You should have a Kubernetes cluster, eksctl-flask-app, 
already created in your AWS account.
If not already, use the command below:
```
eksctl create cluster --name eksctl-flask-app --nodes=2 --version=1.22 --instance-types=t2.medium --region=us-east-2
# Check the status, Nodes should be ready
kubectl get nodes
```
Known Issue - If your default region is us-east-1, then the cluster creation may fail

2. Image registry
We need to have a Docker image built out of a simple flask application.
To deploy a Docker image to a Kubernetes cluster,
we first must put the image in a container registry that the cluster can access.

    1.Go to Docker Hub https://hub.docker.com/
    2.Login and go to the repositories section
    3.Create a public repository named project-4-flask-app-deployment.

3. Build a Docker Image
    The examples/Deploy_Flask_App directory already has a Dockerfile and an app.py available to us. Tag the Docker image with a name matching with the Dockerhub repository name.

    docker build -t jbangala/project-4-flask-app-deployment .
    # Example: docker build -t jbangala/project-4-flask-app-deployment .
    # View the list of images
    docker image ls

4. Push the Local Image to the Dockerhub Repository
Use the following command:

# Dockerhub login from terminal
docker login -u <DockerHub username>
# Example: docker login -u jbanagala
# Syntax: 
docker push <DockerHub username>/<Repo-name>:<tag-name>
# Example: docker push  jbanagala/project-4-flask-app-deployment:latest

The name of the local image should match with the Dockerhub repository name. In case of a name mistmatch, it will generate an error; and you will have to change the tag before pushing, as:

docker tag <local-image-name>:<tag-name> <Repo-name>:<tag-name>

Now you will deploy this (remote) image to your EKS cluster from the command line.

5. Deployment
The manual deployment needs a YAML file that will describe things like number of replicas, deployment strategy, Docker image name, and port on which the application can be accessed.

We have provided you the deployment.yml that contains all the necessary configuration details. Open the file and replace IMAGE_TAG with <DockerHub username>/simple-flask. Also, notice that we have given our deployment the simple-flask-deployment name.
Deploy the application
In you terminal navigate to your exercise folder, and run:

# Run from the cd0157-Server-Deployment-and-Containerization/examples/Deploy_Flask_App directory
# Recheck the cluster status, Nodes should be ready
kubectl get nodes
kubectl apply -f deployment.yml

It will show the message as deployment.apps/project-4-flask-app-deployment created.

    3.Other useful commands are:
        # Verify the deployment
        kubectl get deployments
        # Check the rollout status
        kubectl rollout status deployment/simple-flask-deployment
        # IMPORTANT: Show the service, nodes, and pods in the cluster
        # You will notice that the service does not have an external IP
        kubectl get svc,nodes,pods
        # Show the services in the cluster
        kubectl describe services
        # Display information about the cluster
        kubectl cluster-info

    4.Troubleshoot
        If your pods do not show up as "Ready" while running the kubectl get nodes command, use the following troubleshooting tips:

        # List all namespaces, all pods
        kubectl get all -A
        # Show all events
        kubectl get events -w
        # Show component status
        kubectl get componentstatuses
    5.Expose the service to access the application
Run this command again to realize that our project-4-flask-app-deployment is not exposed yet.
There will be no External IP to access the application.
`kubectl get svc,deployments,nodes,pods`

Let's expose the project-4-flask-app-deployment service to access the application on an <External IP>:<port>.

`kubectl expose deployment project-4-flask-app-deployment --type=LoadBalancer --name=my-service`

The command above will create a new service and expose it on an AWS URL similar to: http://a66cc8ff655d04c47a790a46d36ad783-1087375811.us-east-2.elb.amazonaws.com:8080/ (Do not forget to append the port!).


6. Clean up
If you do not wish to continue to the next page right away,
delete the deployment as well the Kubernetes cluster:

# Delete your deployment
kubectl delete deployments/project-4-flask-app-deployment
# Tear down your cluster
eksctl delete cluster eksctl-flask-app --region=us-east-2